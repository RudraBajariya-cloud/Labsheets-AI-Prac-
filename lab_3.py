# -*- coding: utf-8 -*-
"""AI_LAB_3

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1pgg2WNrbiyrzDDm4upJDAQTW-Y9akgOR

1.Initialize the frontier to have the start node,visited list to NULL,distance = 0.

2.Take out the first node of the frontier and add it to the visited list.

3.Add all unvisited nodes to the frontier.

4.Repeat steps 2 and 3 till either the frontier is empty or we visit the goal state.

BFS -> frontier is stored in a queue

DFS -> frontier is stored in a stack

UCS -> frontier is stored in a Priority Queue/Binary Heap.

In Binary Heap,parent node is the extreme of the children nodes and is present at the root.
"""

#3. UNIFORM COST SEARCH
f1=open("Graph.txt","r")
lines = f1.readlines()
graph=dict()
for line in lines:
  if(len(line.split('\t'))!=2):
    continue
  parts = line.split('\t')
  key = parts[0]
  neighbours=parts[1].split(" ")
  value=[]
  for neighbour in neighbours:
    neighbourVertex=neighbour.split(',')[0]
    distance = int(neighbour.split(',')[1])
    pair = (neighbourVertex,distance)
    value.append(pair)
  graph[key]=value
#print graph
for key in graph.keys():
  line= key+'->'+str(graph[key])
  print(line)

"""HW1. Write a function called getCost(path) which takes the path (from UCS) as input and returns the cost.

HW2. Write a funtion called getSSSP(graph,node) whiich
"""

from queue import PriorityQueue

def ucs(graph, start, goal):
    visited = set()
    frontier = PriorityQueue()
    frontier.put((0, start))
    parent = {}
    cost = {start: 0}

    while not frontier.empty():
        current_cost, current_node = frontier.get()

        # If we reach the goal, reconstruct the path
        if current_node == goal:
            path = []
            while current_node in parent:
                path.append(current_node)
                current_node = parent[current_node]
            path.append(start)
            return path[::-1]  # Return reversed path

        visited.add(current_node)

        # Explore neighbors
        for neighbor, weight in graph[current_node]:
            new_cost = current_cost + weight

            # If the neighbor has not been visited or we found a cheaper path
            if neighbor not in visited or new_cost < cost.get(neighbor, float('inf')):
                cost[neighbor] = new_cost
                parent[neighbor] = current_node
                frontier.put((new_cost, neighbor))

    return None  # If no path is found

ucs(graph,'A','G')

"""HW 1. Write a program to calculate the cost of the path,given the path returned as output from UCS.

"""

def get_cost(graph, start, goal):
    visited = set()
    frontier = PriorityQueue()
    frontier.put((0, start))
    cost = {start: 0}

    while not frontier.empty():
        current_cost, current_node = frontier.get()

        # If we reach the goal, return the total cost
        if current_node == goal:
            return current_cost

        visited.add(current_node)

        # Explore neighbors
        for neighbor, weight in graph[current_node]:
            new_cost = current_cost + weight

            # If the neighbor has not been visited or we found a cheaper path
            if neighbor not in visited or new_cost < cost.get(neighbor, float('inf')):
                cost[neighbor] = new_cost
                frontier.put((new_cost, neighbor))

    return float('inf')  # Return infinity if no path is found

get_cost(graph,'A','G')

"""
HW 2. Djikstra's SSSP.Write a function that takes the graph, as well as a source vertex as input and returns the Djikstra's SSSP as output."""

from queue import PriorityQueue

def dijkstra(graph, start):
    # Dictionary to store the shortest distance to each node
    shortest_distance = {node: float('inf') for node in graph}
    shortest_distance[start] = 0

    # Priority queue to store the nodes to be explored (min-heap)
    frontier = PriorityQueue()
    frontier.put((0, start))

    # Parent dictionary to reconstruct the shortest path
    parent = {start: None}

    while not frontier.empty():
        current_distance, current_node = frontier.get()

        # Explore neighbors of the current node
        for neighbor, weight in graph[current_node]:
            distance = current_distance + weight

            # Only consider this path if it's better
            if distance < shortest_distance[neighbor]:
                shortest_distance[neighbor] = distance
                parent[neighbor] = current_node
                frontier.put((distance, neighbor))

    return shortest_distance, parent

dijkstra(graph, 'A')

from queue import PriorityQueue

def ucs(graph, start, goal):
    visited = set()  # To keep track of visited nodes
    frontier = PriorityQueue()  # Priority queue for UCS
    frontier.put((0, start))  # Put the start node with a priority of 0
    parent = {}  # Dictionary to store parent of each node
    cost = {start: 0}  # Dictionary to store the cost to reach each node

    while not frontier.empty():
        current_cost, node = frontier.get()  # Get the node with the lowest cost

        # If the goal is reached, reconstruct the path
        if node == goal:
            path = []
            while node != start:
                path.append(node)
                node = parent[node]
            path.append(start)
            path.reverse()
            return path, current_cost  # Return the path and the total cost

        # If node is already visited, skip it
        if node in visited:
            continue

        visited.add(node)

        # Explore neighbors
        for neighbor, weight in graph[node].items():
            new_cost = current_cost + weight  # Calculate new cost to reach neighbor

            # If the neighbor hasn't been visited or a lower cost path is found
            if neighbor not in cost or new_cost < cost[neighbor]:
                cost[neighbor] = new_cost  # Update cost to reach neighbor
                parent[neighbor] = node  # Set parent of neighbor to current node
                frontier.put((new_cost, neighbor))  # Add neighbor to frontier with new cost

    return None, float('inf')  # Return None if goal is not reachable


# Example graph:
graph = {
    'A': {'Z': 75, 'T': 118, 'S': 140},
    'B': {'F': 211, 'P': 101, 'G': 90, 'U': 85},
    'C': {'R': 146, 'P': 138, 'D': 120},
    'D': {'C': 120, 'M': 75},
    'E': {'H': 86},
    'F': {'S': 99, 'B': 211},
    'G': {'B': 90},
    'H': {'E': 86, 'U': 98},
    'I': {'N': 87, 'V': 92},
    'L': {'M': 70, 'T': 111},
    'M': {'L': 70, 'D': 75},
    'N': {'I': 87},
    'O': {'Z': 71, 'S': 151},
    'P': {'R': 97, 'C': 138, 'B': 101},
    'R': {'P': 97, 'S': 80, 'C': 146},
    'S': {'O': 151, 'A': 140, 'R': 80, 'F': 99},
    'T': {'A': 118, 'L': 111},
    'U': {'B': 85, 'H': 98, 'V': 142},
    'V': {'U': 142, 'I': 92},
    'Z': {'A': 75, 'O': 71}
}

# Start and goal nodes
start = 'A'
goal = 'B'

path, total_cost = ucs(graph, start, goal)

print(f"Path: {path}, Total cost: {total_cost}")